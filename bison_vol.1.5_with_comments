%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* yylex() and yyin are defined as extern 'cause they are defined externally (in the Flex file) and will be linked at compilation time */

extern int yylex();     
extern FILE* yyin; 

void yyerror(const char *s) {
    fprintf(stderr, "%s\n", s);
}

%}


/* specify the token types /

%token PUBLIC_CLASS CLASS_NAME LEFT_BRACE RIGHT_BRACE PUBLIC PRIVATE QMARK VAR 
%token INT DOUBLE CHAR BOOLEAN STRING EQUAL NEW LEFT_BRACKET RIGHT_BRACKET VOID PROTECTED M_PUBLIC M_PRIVATE
%token COMMA RETURN INT_NUM DOUBLE_NUM CHAR_VAR STRING_VAR TRUE FALSE DOT
%token MUL DIV PLUS MINUS DO WHILE AND OR CHECK_EQUAL LESS GREATER NOT_EQUAL FOR SWITCH CASE 
%token DOUBLE_DOT DEFAULT BREAK PRINT IF ELSE ELSE_IF


/*rules section */

%%

program: public_class
        | program public_class
        ;

public_class: PUBLIC_CLASS CLASS_NAME LEFT_BRACE class_block RIGHT_BRACE
                ;

class_block: variable_declarations method_declarations nested_class
		;


nested_class: public_class | ;


variable_declarations: variable_declaration | variable_declaration variable_declarations | ;


variable_declaration: variable_modifier data_type variable QMARK 
	| variable_modifier data_type variable EQUAL normal_type extra_variables QMARK
	| CLASS_NAME variable EQUAL NEW CLASS_NAME LEFT_BRACKET RIGHT_BRACKET QMARK
	;


extra_variables: COMMA variable EQUAL normal_type 
	| COMMA variable EQUAL normal_type extra_variables
	| ;


method_declarations: method_declaration | method_declaration method_declarations | ;


method_declaration: method_modifier return_type variable LEFT_BRACKET parameters RIGHT_BRACKET LEFT_BRACE method_block return RIGHT_BRACE ;


parameters: data_type variable
	| data_type variable COMMA parameters
	|;


method_block: variable_declarations commands;


commands: command | command commands | ;


command: assignment | do_loop | for_loop | switch_case | break | method_call | print | if_else; 


assignment: variable EQUAL expression QMARK ;

member_access: variable DOT variable LEFT_BRACKET arguments RIGHT_BRACKET
		| variable DOT variable ;


method_call: variable LEFT_BRACKET arguments RIGHT_BRACKET ;


arguments: variable | variable COMMA arguments | normal_type | normal_type COMMA arguments ; 


expression: normal_type | object_instance | member_access | method_call | operations ;


operations: number operator_symbol operations | number | variable operator_symbol operations | variable;


do_loop: DO LEFT_BRACE commands RIGHT_BRACE WHILE LEFT_BRACKET conditions RIGHT_BRACKET QMARK ;


conditions: condition | condition logic_operators conditions ;


condition: variable compare_symbol normal_type 
		| normal_type compare_symbol variable
		| variable compare_symbol VAR
		| normal_type compare_symbol normal_type ;


logic_operators: AND | OR ;


compare_symbol: LESS | GREATER | NOT_EQUAL | CHECK_EQUAL ;


operator_symbol: DIV | MUL | PLUS | MINUS ;


for_loop: FOR LEFT_BRACKET for_assignment QMARK conditions QMARK increment RIGHT_BRACKET LEFT_BRACE commands RIGHT_BRACE ;



for_assignment: variable EQUAL number | variable EQUAL variable ;


increment: variable EQUAL variable operator_symbol number 
		| variable EQUAL variable operator_symbol variable ;


switch_case: SWITCH LEFT_BRACKET variable RIGHT_BRACKET LEFT_BRACE cases DEFAULT commands RIGHT_BRACE
		| SWITCH LEFT_BRACKET variable RIGHT_BRACKET LEFT_BRACE cases RIGHT_BRACE ;


cases: CASE normal_type DOUBLE_DOT commands | CASE normal_type DOUBLE_DOT commands cases ;


if_else: IF LEFT_BRACKET conditions RIGHT_BRACKET LEFT_BRACE commands RIGHT_BRACE else_if else ;



else_if: ELSE_IF LEFT_BRACKET conditions RIGHT_BRACKET LEFT_BRACE commands RIGHT_BRACE 
	| ELSE_IF LEFT_BRACKET conditions RIGHT_BRACKET LEFT_BRACE commands RIGHT_BRACE else_if
	| ;



else: ELSE LEFT_BRACE commands RIGHT_BRACE | ;


number: INT_NUM | DOUBLE_NUM ;


normal_type: INT_NUM | DOUBLE_NUM | TRUE | FALSE | CHAR_VAR | STRING_VAR ; 


object_instance: NEW CLASS_NAME LEFT_BRACKET RIGHT_BRACKET ; 


return: RETURN num QMARK 
	| RETURN variable QMARK 
	| RETURN method_call 
	| RETURN member_access 
	| RETURN operations ; 

break: BREAK QMARK ;


print: PRINT LEFT_BRACKET STRING_VAR print_vars RIGHT_BRACKET QMARK ;


print_vars: COMMA variable | COMMA variable print_vars | ;


variable_modifier: PUBLIC | PRIVATE | ;


return_type: INT | DOUBLE | CHAR | BOOLEAN | STRING | VOID ; 


data_type: INT | DOUBLE | CHAR | BOOLEAN | STRING ;


method_modifier: M_PUBLIC | M_PRIVATE | PROTECTED ;


variable: VAR | CLASS_NAME ;


num: INT_NUM | DOUBLE_NUM ;

%%


/*  read the file, set it as input for the parser, 
and then invoke yyparse() to start parsing.  */

int main(int argc, char** argv) { 
    char filename[] = "file.txt";
    if(argc == 2)
    {
	strcpy(filename, argv[1]);
    }
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror(filename);
        return 1;
    }
    yyin = file;
    yyparse();
    fclose(file);
    return 0;
}
